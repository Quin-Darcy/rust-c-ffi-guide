#![allow(dead_code)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use std::marker::PhantomData;

// Define a module to encapsulate the raw FFI binding generated by bindgen.
// This isolates it from the rest of the crate and prevents namespace pollution.
mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

struct Buffer {
    data: Vec<u8>,

    // Phantom data to prevent auto Send/Sync traits
    _marker: PhantomData<*const ()>,
}

impl Buffer {
    fn new(size: usize) -> Self {
        Buffer {
            data: vec![0u8; size],
            _marker: PhantomData,
        }
    }

    fn fill(&mut self) -> Result<(), String> {
        // Convert usize to c_int with bounds check
        let c_size = ::std::os::raw::c_int::try_from(self.data.len())
            .map_err(|_| "Size too large for C integer".to_string())?;

        // Get a mutable pointer to the buffers data
        let ptr = self.data.as_mut_ptr() as *mut ::std::os::raw::c_char;

        // Call FFI binding
        let result = unsafe {
            bindings::fill_buffer(ptr, c_size)
        };

        // Error handle
        match result {
            n if n >= 0 => Ok(()),
            _ => Err("Failed to fill buffer".to_string()),
        }
    }

    // Method for safe immutable access to buffer
    fn as_slice(&self) -> &[u8] {
        &self.data
    }

    // Method for safe mutable access to buffer
    fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.data
    }
}

fn main() -> Result<(), String> {
    // Create buffer
    let size = 20;
    let mut buffer = Buffer::new(size);

    buffer.fill()?;

    println!("Buffer successfully filled with {} bytes", buffer.data.len());
    println!("First few bytes: {:?}", &buffer.as_slice()[..5]);

    // Example of mutable access
    buffer.as_mut_slice()[0] = 42;
    println!("After modification, first byte: {}", buffer.as_slice()[0]);

    Ok(())
}
