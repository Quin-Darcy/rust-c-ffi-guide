#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use std::marker::PhantomData;

// Define a module to encapsulate the raw FFI binding generated by bindgen.
// This isolates it from the rest of the crate and prevents namespace pollution.
mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

// Struct to hide the raw pointer and from which we can extend
// with implementations that safely wrap the unsafe code
struct Buffer {
    ptr: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    // Phantom data to prevent automatic Send/Sync implementation
    _marker: PhantomData<*const ()>,
}

// Safe implementations which return Result types that
// properly handles error cases
impl Buffer {
    fn new(size: usize) -> Result<Self, String> {
        // Convert usize to c_int with bounds checking
        let c_size = ::std::os::raw::c_int::try_from(size)
            .map_err(|_| "Size too large for C integer".to_string())?;

        let ptr = unsafe { bindings::allocate_buffer(c_size) };
        if ptr.is_null() {
            return Err("Failed to allocate buffer".to_string());
        }
        Ok(Buffer { ptr, size: c_size, _marker: PhantomData })
    }

    fn fill(&mut self) -> Result<(), String> {
        let result = unsafe { bindings::fill_buffer(self.ptr, self.size) };
        match result {
            n if n >=0 => Ok(()),
            _ => Err("Invalid arguments were provided".to_string()),
        }
    }
}

// This ensures the buffer is always freed
// regardless of when it goes out of scope
impl Drop for Buffer {
   fn drop(&mut self) {
        let result = unsafe { bindings::free_buffer(self.ptr) };
        if result != 0 {
            eprintln!("Warning! Failed to free buffer");
        }
   }
}

fn main() -> Result<(), String> {
    let size = 20;
    let mut buffer = Buffer::new(size)?;

    buffer.fill()?;

    println!("Buffer successfully filled");

    Ok(())
}
